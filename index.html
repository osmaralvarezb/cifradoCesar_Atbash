<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cifrado C√©sar y Atbash (ASCII + alfabeto configurable)</title>
    <style>
      :root {
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
      }
      body {
        margin: 0;
        background: #0b1020;
        color: #eaf0ff;
      }
      header {
        padding: 20px;
        background: #0f1630;
        border-bottom: 1px solid #24305a;
      }
      header h1 {
        margin: 0;
        font-size: 18px;
      }
      header p {
        margin: 6px 0 0;
        opacity: 0.85;
        font-size: 13px;
      }
      main {
        max-width: 980px;
        margin: 0 auto;
        padding: 18px;
        display: grid;
        gap: 14px;
      }
      .card {
        background: #101a3a;
        border: 1px solid #24305a;
        border-radius: 14px;
        padding: 14px;
      }
      .row {
        display: grid;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .row.cols2 {
          grid-template-columns: 1fr 1fr;
        }
      }
      label {
        font-size: 12px;
        opacity: 0.85;
        display: block;
        margin-bottom: 6px;
      }
      textarea,
      input,
      select,
      button {
        width: 100%;
        box-sizing: border-box;
        border-radius: 12px;
        border: 1px solid #2b3a6e;
        background: #0b1330;
        color: #eaf0ff;
        padding: 10px 12px;
        font-size: 14px;
        outline: none;
      }
      textarea {
        min-height: 120px;
        resize: vertical;
      }
      button {
        cursor: pointer;
        background: #1b2a5e;
        border-color: #3750a3;
      }
      button:hover {
        filter: brightness(1.1);
      }
      .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 6px 10px;
        border: 1px solid #2b3a6e;
        border-radius: 999px;
        font-size: 12px;
        opacity: 0.9;
      }
      .muted {
        opacity: 0.8;
        font-size: 12px;
        line-height: 1.45;
      }
      .grid3 {
        display: grid;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .grid3 {
          grid-template-columns: 1.2fr 0.8fr 1fr;
        }
      }
      details {
        border: 1px dashed #2b3a6e;
        border-radius: 12px;
        padding: 10px 12px;
      }
      summary {
        cursor: pointer;
      }
      code,
      pre {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      pre {
        background: #070d22;
        border: 1px solid #24305a;
        border-radius: 12px;
        padding: 12px;
        overflow: auto;
      }
      .ok {
        color: #b8ffcc;
      }
      .warn {
        color: #ffd28a;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        üîê Cifrado / Descifrado: C√©sar y Atbash (ASCII + alfabeto configurable)
      </h1>
      <p>
        Incluye detecci√≥n del m√≥dulo (C√©sar/Atbash) y estimaci√≥n del
        desplazamiento en C√©sar.
      </p>
    </header>

    <main>
      <section class="card grid3">
        <div>
          <label for="mode">M√≥dulo</label>
          <select id="mode">
            <option value="cesar">C√©sar</option>
            <option value="atbash">Atbash</option>
          </select>
          <div style="height: 10px"></div>

          <label for="action">Acci√≥n</label>
          <select id="action">
            <option value="encrypt">Cifrar</option>
            <option value="decrypt">Descifrar</option>
          </select>

          <div style="height: 10px"></div>
          <label for="shift">Desplazamiento (solo C√©sar)</label>
          <input id="shift" type="number" value="3" min="-9999" max="9999" />
          <p class="muted">
            En C√©sar se rota dentro del conjunto de caracteres definido
            (alfabeto). Si un car√°cter no est√° en el alfabeto, se deja igual.
          </p>
        </div>

        <div>
          <label for="alphabet">Conjunto de caracteres (alfabeto)</label>
          <textarea id="alphabet" spellcheck="false">
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:¬°!¬ø?()[]{}-_@#$/\&amp;+=*&quot;'√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë</textarea
          >
          <p class="muted">
            Debe ser una cadena con caracteres √∫nicos (sin repetidos). Se usa
            como base (ASCII) para mapear por posici√≥n.
          </p>
          <button id="sanitizeBtn">Eliminar repetidos</button>
        </div>

        <div>
          <div class="pill">
            <strong>Detecci√≥n:</strong> <span id="detectBadge">‚Äî</span>
          </div>
          <div style="height: 10px"></div>
          <div class="pill">
            <strong>Shift estimado:</strong> <span id="shiftGuess">‚Äî</span>
          </div>
          <div style="height: 10px"></div>
          <div class="pill">
            <strong>Estado:</strong> <span id="status">Listo</span>
          </div>
          <div style="height: 12px"></div>

          <button id="runBtn">Ejecutar</button>
          <div style="height: 10px"></div>
          <button id="swapBtn">Intercambiar entrada ‚áÑ salida</button>
          <div style="height: 10px"></div>
          <button id="copyBtn">Copiar salida</button>

          <p class="muted">
            Nota: Atbash es autoinverso (cifrar = descifrar). En C√©sar,
            descifrar equivale a usar el shift negativo.
          </p>
        </div>
      </section>

      <section class="card row cols2">
        <div>
          <label for="inputText">Entrada</label>
          <textarea
            id="inputText"
            placeholder="Escribe aqu√≠ el texto..."
          ></textarea>
        </div>
        <div>
          <label for="outputText">Salida</label>
          <textarea id="outputText" readonly></textarea>
        </div>
      </section>

      <section class="card">
        <details>
          <summary>
            <strong>üìò Documentaci√≥n segura (para tu entrega)</strong>
          </summary>
          <p class="muted">
            La idea es que la documentaci√≥n sea revisable sin ‚Äúimpresiones‚Äù y
            sin exponer innecesariamente secretos. Recomendaci√≥n: publica el
            sitio con este sistema y el c√≥digo en un repositorio (GitHub) con
            README bien explicado, o en un Google Doc con acceso controlado.
          </p>
          <ul class="muted">
            <li>
              <strong>Sin claves hardcodeadas:</strong> aqu√≠ no hay llaves
              secretas; el shift lo elige el usuario.
            </li>
            <li>
              <strong>Validaci√≥n:</strong> se valida que el alfabeto tenga
              caracteres √∫nicos.
            </li>
            <li>
              <strong>Principio de m√≠nimo privilegio:</strong> el sitio no pide
              permisos especiales.
            </li>
            <li>
              <strong>Explicaci√≥n t√©cnica:</strong> abajo est√° el pseudoc√≥digo y
              el detalle de ASCII/posiciones.
            </li>
          </ul>
          <pre id="docBlock"></pre>
        </details>
      </section>
    </main>

    <script>
      // ===== Utilidades =====
      const $ = (id) => document.getElementById(id);

      function uniqueChars(str) {
        const seen = new Set();
        let out = "";
        for (const ch of str) {
          if (!seen.has(ch)) {
            seen.add(ch);
            out += ch;
          }
        }
        return out;
      }

      function validateAlphabet(alphabet) {
        if (!alphabet || alphabet.length < 2)
          return {
            ok: false,
            msg: "El alfabeto debe tener al menos 2 caracteres.",
          };
        const u = uniqueChars(alphabet);
        if (u.length !== alphabet.length)
          return {
            ok: false,
            msg: "El alfabeto tiene caracteres repetidos (usa 'Eliminar repetidos').",
          };
        return { ok: true, msg: "OK" };
      }

      // ===== Cifrado C√©sar (sobre posiciones del alfabeto) =====
      function cesarTransform(text, alphabet, shift) {
        const n = alphabet.length;
        // normalizamos shift a rango [0, n-1]
        let k = shift % n;
        if (k < 0) k += n;

        let out = "";
        for (const ch of text) {
          const idx = alphabet.indexOf(ch);
          if (idx === -1) {
            out += ch;
          } else {
            out += alphabet[(idx + k) % n];
          }
        }
        return out;
      }

      // ===== Atbash (reflejo dentro del alfabeto) =====
      function atbashTransform(text, alphabet) {
        const n = alphabet.length;
        let out = "";
        for (const ch of text) {
          const idx = alphabet.indexOf(ch);
          if (idx === -1) out += ch;
          else out += alphabet[n - 1 - idx];
        }
        return out;
      }

      // ===== Detecci√≥n del m√≥dulo (heur√≠stica) =====
      // 1) Si aplicar Atbash al texto produce algo "m√°s plausible" (m√°s caracteres en alfabeto original de letras/espacios),
      //    se sugiere Atbash.
      // 2) Para C√©sar, se prueba cada shift y se toma el que maximiza la "plausibilidad" (espacios + letras comunes).
      function plausibilityScore(s) {
        // Score simple: cuenta letras, espacios y signos b√°sicos; penaliza caracteres raros.
        let score = 0;
        for (const ch of s) {
          if (/[A-Za-z√Å√â√ç√ì√ö√°√©√≠√≥√∫√ë√±]/.test(ch)) score += 2;
          else if (ch === " ") score += 2;
          else if (/[0-9.,;:¬°!¬ø?\-()]/.test(ch)) score += 1;
          else score -= 1;
        }
        return score;
      }

      function guessCesarShift(cipherText, alphabet) {
        const n = alphabet.length;
        let bestShift = 0;
        let bestScore = -Infinity;
        let bestPlain = cipherText;

        for (let s = 0; s < n; s++) {
          // "descifrar" = shift negativo (equivale a n - s en cifrado)
          const candidate = cesarTransform(cipherText, alphabet, -s);
          const sc = plausibilityScore(candidate);
          if (sc > bestScore) {
            bestScore = sc;
            bestShift = s;
            bestPlain = candidate;
          }
        }
        return { bestShift, bestScore, bestPlain };
      }

      function detectModule(text, alphabet) {
        const atbashCandidate = atbashTransform(text, alphabet);
        const atbashScore = plausibilityScore(atbashCandidate);

        const cesarGuess = guessCesarShift(text, alphabet);
        const cesarScore = cesarGuess.bestScore;

        // Decide por mayor score, pero con margen:
        if (atbashScore > cesarScore + 3)
          return { module: "Atbash", shift: "‚Äî", sample: atbashCandidate };
        return {
          module: "C√©sar (probable)",
          shift: String(cesarGuess.bestShift),
          sample: cesarGuess.bestPlain,
        };
      }

      // ===== UI =====
      function setStatus(msg, type = "ok") {
        $("status").textContent = msg;
        $("status").className = type === "warn" ? "warn" : "ok";
      }

      function buildDocText() {
        return [
          `DOCUMENTACI√ìN T√âCNICA (RESUMEN)

1) Enfoque con ASCII y alfabeto configurable
- El sistema trabaja con caracteres (que en computaci√≥n se representan como c√≥digos, por ejemplo ASCII/Unicode).
- En vez de asumir solo A-Z, el usuario define un conjunto de caracteres (alfabeto).
- Cada car√°cter del alfabeto tiene una posici√≥n i (0..n-1). El cifrado opera sobre estas posiciones.

2) Cifrado C√©sar (rotaci√≥n)
Dado:
- alfabeto = cadena de n caracteres √∫nicos
- shift = desplazamiento entero k
Para cada car√°cter c del texto:
- si c NO est√° en alfabeto => se deja igual
- si c est√° en alfabeto en posici√≥n i => se reemplaza por alfabeto[(i + k) mod n]

3) Cifrado Atbash (reflejo)
Para cada car√°cter c:
- si c NO est√° en alfabeto => se deja igual
- si c est√° en alfabeto en posici√≥n i => se reemplaza por alfabeto[(n-1) - i]
Atbash es autoinverso: aplicar Atbash dos veces devuelve el original.

4) Detecci√≥n del m√≥dulo (heur√≠stica)
- Se intenta "explicar" el texto con Atbash y con C√©sar.
- Para C√©sar se prueban shifts posibles (0..n-1) y se escoge el que produce texto m√°s plausible
  (m√°s letras/espacios y menos caracteres raros).
- Se reporta el m√≥dulo m√°s probable y el shift estimado.

5) Seguridad (documentaci√≥n segura)
- No hay llaves secretas incrustadas en el c√≥digo.
- Se valida el alfabeto (sin repetidos).
- Se recomienda publicar el c√≥digo con control de acceso o al menos sin exponer datos personales.
`,
        ].join("\n");
      }

      function run() {
        const mode = $("mode").value;
        const action = $("action").value;
        let alphabet = $("alphabet").value;
        const v = validateAlphabet(alphabet);
        if (!v.ok) {
          setStatus(v.msg, "warn");
          return;
        }

        const input = $("inputText").value;
        let out = "";

        if (mode === "cesar") {
          const shift = parseInt($("shift").value || "0", 10) || 0;
          const k = action === "encrypt" ? shift : -shift;
          out = cesarTransform(input, alphabet, k);
        } else {
          out = atbashTransform(input, alphabet);
        }

        $("outputText").value = out;

        // detecci√≥n sobre el texto de salida o entrada seg√∫n convenga:
        const detectOn = action === "encrypt" ? out : input;
        const det = detectModule(detectOn, alphabet);
        $("detectBadge").textContent = det.module;
        $("shiftGuess").textContent = det.shift;

        setStatus("Ejecutado correctamente", "ok");
      }

      $("runBtn").addEventListener("click", run);

      $("sanitizeBtn").addEventListener("click", () => {
        const cleaned = uniqueChars($("alphabet").value);
        $("alphabet").value = cleaned;
        const v = validateAlphabet(cleaned);
        setStatus(
          v.ok ? "Alfabeto limpio (sin repetidos)" : v.msg,
          v.ok ? "ok" : "warn",
        );
      });

      $("swapBtn").addEventListener("click", () => {
        const a = $("inputText").value;
        $("inputText").value = $("outputText").value;
        $("outputText").value = a;
        setStatus("Intercambiado", "ok");
      });

      $("copyBtn").addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText($("outputText").value);
          setStatus("Salida copiada al portapapeles", "ok");
        } catch {
          setStatus("No se pudo copiar (permiso del navegador)", "warn");
        }
      });

      // init docs
      $("docBlock").textContent = buildDocText();
    </script>
  </body>
</html>
